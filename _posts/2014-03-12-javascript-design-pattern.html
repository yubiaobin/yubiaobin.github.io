---
layout: default_post
title :  代码设计模式
---




<h3>代码设计模式</h3>


<p>本文主要讲述一下，什么是设计模式（Design pattern），作为敲键盘的我们要如何学习设计模式。设计模式真的是一把万能钥匙么？</p>
<p> 各个代码的设计模式几乎每个人都知晓，就算不会那也一定在一些装逼的大牛（部分而已）口中听过。但可能很少有人知道设计模式的由来：</p>
<p>设计模式该术语源自Erich Gamma等人在上世纪90年代从建筑设计领域引入到计算机科学的（很难想象到底有多大关联）。它是对软件设计中一些反复出现，普遍存在的问题所提出的解决方案。所以说设计模式并不是某种语言的某块代码，设计模式是一种思想，提供给在编码时候遇到的各种问题是可以采取的解决方案，更倾向于一种逻辑思维，而不是万能代码块。</p>

<p>设计模式使人可以更加简单方便的复用一些较为成功的设计和体系结构，使用设计模式来使人理解整个系统的开发思路。</p>


<h3>设计模式的四要素</h3>

<ul>
	<li><strong> 模式名称（pattern name）：</strong>助记名，以几个词来描述问题，解决方案和效果。模式名可以帮助我们思考，一边与其他程序员进行设计思想交流。</li>
	<li><strong> 问题（problem）：</strong>描绘使用设计模式的具体情况。解释设计问题和问题存在的因果，可能描述特定的设计问题，也可能描述导致不灵活的设计的类或者对象结构等。</li>
	<li><strong> 解决方案（solution）：</strong>描述设计的组成成分，它们之间的相互关系与各自的职责和协作方式。解决方案并不具体的描述某种设计的实现，而是提供设计问题的抽象描述和怎样用一些一般意义的元素来解决这个问题。</li>
	<li><strong>  效果（consequences）：</strong>描述模式的应用效果以及使用模式需要权衡的问题，虽然很少提到模式的效果，但是对于评价该模式在该问题下是有很重要的意义。模式效果包括此模式对于系统的灵活性，扩充性或者可移植性的影响，显示列出这些效果可以客观的评价该模式对于该问题的适用性。</li>
</ul>



<h3>23种设计模式</h3>
<ul>
	<li><strong>创建型模式：</strong>单例模式，抽象工厂模式，建造者模式，工厂模式与原型模式。</li>
	<li><strong>结构型模式：</strong>适配器模式，桥接模式，装饰者模式，组合模式，外观模式，享元模式以及代理模式。</li>
	<li><strong>行为型模式：</strong>模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式和访问者模式。</li>
</ul>



<h3>创建型模式：</h3>




<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>





<h4>工厂方法模式（Factory Method）</h4>
<p>其核心工厂类不再负责所有的产品撞见，而是将具体工作委托给子类，自身成为一个抽象的工厂角色，仅负责给出工厂类必须实现的接口，而不需要关系具体哪种产品被实例化的细节。</p>
<P><strong> 意图：</strong></P>
<p> 定义一个用于创建对象接口，让子类来决定实例化哪一个类，将类的实例化延迟到其子类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li> 当一个类不知道它所必须创建的对象的类的时候。</li>
	<li>当一个类希望由其子类来创建对象的时候。</li>
</ul>




<h4>建造者模式（Builder）</h4>
<p> 将对象的内部表象和对象的生产过程分割开来，从而使得一个建造过程具有不同内部表象的产品对象。建造模式使得产品内部表象可以独立出来变化，客户不需要知道内部细节，可以强制实行一种分步建造过程。</p>
<P><strong> 意图：</strong></P>
<p> 将一个复杂的对象的构建与它的表现分离，使同样的构建形式可以得到不同的表示。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>将复杂对象的算法需要独立于对象的组成部分以及装配方式的时候。</li>
	<li>构造过程允许构造不同的对象表示。</li>
</ul>




<h4>适配器模式（Adapter）</h4>
<p>将一个类的接口变为客户端所希望的接口类型，从而使原先因接口不匹配而无法工作的两个类可以一起工作。</p>
<P><strong> 意图：</strong></P>
<p> 将某个接口改装变为所需要类型的接口，也可以是原本不兼容的接口适配成兼容。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>希望使用一个已经存在的类，但是与你所需要的接口有些不吻合时。</li>
	<li>希望创建一个可以复用的类，可以与其他已存在或者未存在的类进行协同工作。</li>
</ul>



<h4>桥接模式（Bridge）</h4>
<p> 将抽象画和实例化解耦，使得两者可以独立变化。即降低耦合度。也就是说将抽象化和实例化之间的关系使用组合/聚合的关系而非继承关系，两者可以独立的变化。</p>
<P><strong> 意图：</strong></P>
<p> 将抽象部分与它的实现部分分离，使它们可以独立的变化。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>在对于抽象部分和实现部分不希望使用固定的关系。</li>
	<li>类的抽象和类的实现都应该都应该可以可以通过生成子类的方式来加以扩充。</li>
	<li>对一个抽象的实现部分的修改应对客户不产生影响。</li>
	<li>希望在多个对象之间共享（比如使用引用计数），但是客户不知道该点。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>


<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>


<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>


<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>


<h4>抽象工厂模式（Abstract Factory）</h4>
<p>客户类与工厂类分开，当客户需要某种产品时向对应工厂发出请求。缺点是当产品需要修改时，工厂类也需要做相应的修改。</p>
<P><strong> 意图：</strong></P>
<p> 提供一个创建一系列相关或者相互依赖的对象接口，无需指定它们具体的类。</p>
<p><strong>适用性：</strong></p>
<ul>
	<li>一个系统要独立于它的产品创建，组合的时候。</li>
	<li>一个系统要由多个产品系列中的一个来配置的时候。</li>
	<li>强调一系列相关产品对象设计以便进行联合使用时。</li>
	<li>对于一个产品库，只想显示接口而不是具体的实现的时候。</li>
</ul>



























































