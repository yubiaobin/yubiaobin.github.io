---
layout: default_post
title : WEBKIT内核之——HTML部分（二）
---


<h3>HTML Parser</h3>




<p>HTML语法解析器</p>

<p>HTML Parser意为语法解析器，它通过HTMLTokenizer识别出的一个一个的标识（tag）来创建Element(Node)，把Element组织成一个DOM Tree， 同时，同步生成Render Tree。</p>



<p>因为webkit支持边解析边绘制，也支持多线程，所以HTMLTokenizer的write函数首先会判断上次丢过来的数据是否已解析完，否则追加到上次的数据后面。</p>


<p> write函数里有一个大的while循环，用于逐个字符的解析，这里代码太多，只贴一下重点，我补上注释说明：</p>
	{% highlight javascript %}
 if (tokenizer) {
        ASSERT(!tokenizer->wantsRawData());
        tokenizer->write(decoded, true);
	{% endhighlight %}


    {% highlight javascript %}
 while (!src.isEmpty() && (!frame || !frame->loader()->isScheduledLocationChangePending())) {
        UChar cc = *src;                    //从html数据Buffer中取出一个字符
        bool wasSkipLF = state.skipLF();            //是否要跳过回车
        if (wasSkipLF)
            state.setSkipLF(false);
        if (wasSkipLF && (cc == '\n'))
            src.advance();
        else if (state.needsSpecialWriteHandling()) {
            if (state.hasEntityState())
                state = parseEntity(src, dest, state, m_cBufferPos, false, state.hasTagState());
            else if (state.inComment())     //注释文本，如：<!--这里是注释 -->
                state = parseComment(src, state);
            else if (state.inDoctype())         //HTML的DocType
                state = parseDoctype(src, state);
            else if (state.inServer())      //asp或jsp的服务端代码，如：<%***%>
                state = parseServer(src, state);
            else if (state.startTag()) {        //重点注意：这里是检测到 '<'字符，

    {% endhighlight %}

<p>在检测到'<'字符后，表示后面跟的就是标签(html Tag)啦，这条分支里主要有两个函数：</p>

<p> processToken和parseToken。 这里是重点。。。。</p>

<p>*: processToken的作用是，在开始一个新的Tag之前，先看一下上一个tag是否已经处理完毕了？因为webkit的兼容性非常好，举例如有“<begin>”而没有“</end>”时，这里能兼容到，而不会因为网页设计人员的失误，导致网页绘制失败。(该函数还有另外一个作用，下面会介绍)
  *: parseTag函数，看名字就知道啦，它就是真正开始词法分析一个html tag标签的函数。</p>


<p>parseTag函数里也是一个大的while,状态机，state变量维护这个状态机，有如下几种状态：</p>



    {% highlight javascript %}
	enum TagState {
        NoTag = 0,
        TagName = 1,
        SearchAttribute = 2,
        AttributeName = 3,
        SearchEqual = 4,
        SearchValue = 5,
        QuotedValue = 6,
        Value = 7,
        SearchEnd = 8
    };

    {% endhighlight %}



<p>TagName: 一个HTML Tag的开始，它会把Tag的名字存在一个叫Token的成员变量里，它永远保存当前正在Parser的Tag的数据。
    AttributeName: 在处理这个状态时，会把所有的大写转为小写。因为html标准中的attribute是不区分大小写的，这样做的目的是加快后面字符比较的速度。
    SearchEqual: 循环到到'='时，会把attributeName添加到currToken这个Token里。
    SearchEnd: 表示当前的Tag全部解析完了，噢，终于完整地解析完一个Tag了，这里该干嘛了？ 当然是生成DOM节点啦，
    这个时候，token成员类变里已经存下了：Tag的名字，所有的attribute和value，有了这些后，会调用：
     RefPtr<Node> n = processToken();</p>



<p>processToken就是真正生成DOM节点和Render节点的函数。
   processToken函数会调用parser->parseToken(&currToken);  
   该函数定义：PassRefPtr<Node> HTMLParser::parseToken(Token* t)。 返回的就是一个Node的节点， Node类是所有DOM节点的父类。</p>

<p>HTMLParser::parseToken函数重点代码介绍：
    RefPtr<Node> n = getNode(t);    //这里返回Node节点，  往里面跟，会发现它用了很多设计模式的东东
    if (!insertNode(n.get(), t->flat)) {        //会调用Node* newNode = current->addChild(n); 把当前的新节点加入到DOM Tree中。</p>




<p>接下来会调用Element::attach，创建相对应的Render节点，代码如下：</p>


    {% highlight javascript %}
void Element::attach()
{
    createRendererIfNeeded();
    ContainerNode::attach();
    if (ElementRareData* rd = rareData()) {
        if (rd->m_needsFocusAppearanceUpdateSoonAfterAttach) {
            if (isFocusable() && document()->focusedNode() == this)
                document()->updateFocusAppearanceSoon();
            rd->m_needsFocusAppearanceUpdateSoonAfterAttach = false;
        }
    }

    {% endhighlight %}


<p>真正创建Render的地方：
   RenderObject::createObject()， 该函数会根据不同的type，而创建不同的Render节点。</p>







<!-- <p class="pege_tail">参考<a href="http://blog.csdn.net/hgl868/article/details/7617191" target="_blank">webkit Parser模块</a></p> -->


